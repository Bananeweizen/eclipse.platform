package org.eclipse.ant.internal.ui;/* * (c) Copyright IBM Corp. 2000, 2001. * All Rights Reserved. */ import java.net.*;import java.util.*;import org.apache.tools.ant.Project;import org.eclipse.jface.action.*;import org.eclipse.jface.preference.PreferenceConverter;import org.eclipse.jface.resource.ImageDescriptor;import org.eclipse.jface.text.*;import org.eclipse.jface.util.*;import org.eclipse.swt.SWT;import org.eclipse.swt.custom.StyleRange;import org.eclipse.swt.graphics.*;import org.eclipse.swt.layout.*;import org.eclipse.swt.widgets.*;import org.eclipse.ui.IActionBars;import org.eclipse.ui.part.ViewPart;import org.eclipse.ui.texteditor.FindReplaceAction;import org.eclipse.ui.texteditor.ITextEditorActionConstants;public class AntConsole extends ViewPart {	public final static String CONSOLE_ID = "org.eclipse.ant.ui.antconsole";	public final static String PROPERTY_PREFIX_FIND = "find_action.";		private TextViewer viewer;	private Action copyAction;	private Action selectAllAction;	private Action clearOutputAction;	private Action findAction;	private IDocument document;	private Vector styleRangeVector;	static Color ERROR_COLOR;	static Color WARN_COLOR;	static Color INFO_COLOR;	static Color VERBOSE_COLOR;	static Color DEBUG_COLOR;	static Font ANT_FONT;	private static AntPropertyChangeListener changeListener = AntPropertyChangeListener.getInstance();	// a Vector that keeps track of al the instances of this class so that they can share the Colors and the Font	static Vector instances = new Vector();/** * Constructor for AntConsole */public AntConsole() {	super();		if (instances.size() == 0) {		// first time there is an instance of this class: intantiate the colors and register the listener		ERROR_COLOR = new Color(null, PreferenceConverter.getColor(AntUIPlugin.getPlugin().getPreferenceStore(),IAntPreferenceConstants.CONSOLE_ERROR_RGB));		WARN_COLOR = new Color(null, PreferenceConverter.getColor(AntUIPlugin.getPlugin().getPreferenceStore(),IAntPreferenceConstants.CONSOLE_WARNING_RGB));		INFO_COLOR = new Color(null, PreferenceConverter.getColor(AntUIPlugin.getPlugin().getPreferenceStore(),IAntPreferenceConstants.CONSOLE_INFO_RGB));		VERBOSE_COLOR = new Color(null, PreferenceConverter.getColor(AntUIPlugin.getPlugin().getPreferenceStore(),IAntPreferenceConstants.CONSOLE_VERBOSE_RGB));		DEBUG_COLOR = new Color(null, PreferenceConverter.getColor(AntUIPlugin.getPlugin().getPreferenceStore(),IAntPreferenceConstants.CONSOLE_DEBUG_RGB));		ANT_FONT = new Font(null, PreferenceConverter.getFontData(AntUIPlugin.getPlugin().getPreferenceStore(),IAntPreferenceConstants.CONSOLE_FONT));			AntUIPlugin.getPlugin().getPreferenceStore().addPropertyChangeListener(changeListener);	}		instances.add(this);	document = new Document();	styleRangeVector = new Vector(5);}protected void addContributions() {	// Create the actions.	copyAction = new Action(Policy.bind("console.copy")) {		public void run() {			copySelectionToClipboard();		}	};		selectAllAction = new Action(Policy.bind("console.selectAll")) {		public void run() {			selectAllText();		}	};		clearOutputAction = new Action(Policy.bind("console.clearOutput")) {		public void run() {			clearOutput();		}	};	clearOutputAction.setImageDescriptor(getImageDescriptor("icons/basic/clcl16/clear.gif"));		findAction = new FindReplaceAction(		AntUIPlugin.getResourceBundle(),		PROPERTY_PREFIX_FIND,		this);	findAction.setEnabled(true);	// In order for the clipboard actions to accessible via their shortcuts	// (e.g., Ctrl-C, Ctrl-V), we *must* set a global action handler for	// each action	IActionBars actionBars= getViewSite().getActionBars();	actionBars.setGlobalActionHandler(ITextEditorActionConstants.COPY, copyAction);	actionBars.setGlobalActionHandler(ITextEditorActionConstants.FIND, findAction);	actionBars.setGlobalActionHandler(ITextEditorActionConstants.SELECT_ALL, selectAllAction);			MenuManager mgr = new MenuManager();	mgr.setRemoveAllWhenShown(true);	mgr.addMenuListener(new IMenuListener() {		public void menuAboutToShow(IMenuManager mgr) {			fillContextMenu(mgr);		}	});	Menu menu = mgr.createContextMenu(viewer.getControl());	viewer.getControl().setMenu(menu);}public void append(String value) {	append(value, Project.MSG_INFO);}public void append(final String value, final int ouputLevel) {	getViewSite().getShell().getDisplay().syncExec(new Runnable() {		public void run() {			int start = document.get().length();			document.set(document.get() + value);			setOutputLevelColor(ouputLevel, start, value.length());			if (value.length() > 0 && viewer != null)				viewer.revealRange(document.get().length() - 1, 1);		}	});}private void setOutputLevelColor(int level, int start, int end) {	switch (level) {		case Project.MSG_ERR: 			addRangeStyle(start, end, ERROR_COLOR); 			break;		case Project.MSG_WARN: 			addRangeStyle(start, end, WARN_COLOR); 			break;		case Project.MSG_INFO: 			addRangeStyle(start, end, INFO_COLOR); 			break;		case Project.MSG_VERBOSE: 			addRangeStyle(start, end, VERBOSE_COLOR); 			break;		case Project.MSG_DEBUG: 			addRangeStyle(start, end, DEBUG_COLOR); 			break;		default: 			addRangeStyle(start, end, INFO_COLOR);	}}private void addRangeStyle(int start, int length, Color color) {	if (styleRangeVector.size() != 0) {		StyleRange lastStyle = (StyleRange) styleRangeVector.lastElement();		if (color.equals(lastStyle.foreground))			lastStyle.length += length;		else			styleRangeVector.add(new StyleRange(start, length, color, null));	} else		styleRangeVector.add(new StyleRange(start, length, color, null));	StyleRange[] styleArray = (StyleRange[]) styleRangeVector.toArray(new StyleRange[styleRangeVector.size()]);				if (viewer != null)		viewer.getTextWidget().setStyleRanges(styleArray);}protected void copySelectionToClipboard() {	viewer.doOperation(viewer.COPY);}public void clearOutput() {	document.set("");	styleRangeVector.removeAllElements();}public void updateFont() {	if (viewer != null)		viewer.getTextWidget().setFont(ANT_FONT);}protected void fillContextMenu(IMenuManager manager) {	copyAction.setEnabled(viewer.canDoOperation(viewer.COPY));	selectAllAction.setEnabled(viewer.canDoOperation(viewer.SELECT_ALL));	manager.add(copyAction);	manager.add(selectAllAction);	manager.add(new Separator());	manager.add(findAction);	manager.add(clearOutputAction);}public Object getAdapter(Class required) {	if (IFindReplaceTarget.class.equals(required)) // and if viewer==null ?		return viewer.getFindReplaceTarget();	return super.getAdapter(required);}protected ImageDescriptor getImageDescriptor(String relativePath) {	try {		URL installURL = AntUIPlugin.getPlugin().getDescriptor().getInstallURL();		URL url = new URL(installURL,relativePath);		return ImageDescriptor.createFromURL(url);	} catch (MalformedURLException e) {		return null;	}}protected void selectAllText() {	viewer.doOperation(viewer.SELECT_ALL);}/** * @see WorkbenchPart#setFocus() */public void setFocus() {}/** * @see WorkbenchPart#createPartControl(Composite) */public void createPartControl(Composite parent) {	Composite composite = new Composite(parent, SWT.NULL);	GridLayout compositeLayout = new GridLayout();	compositeLayout.marginHeight = 0;	compositeLayout.marginWidth = 0;	composite.setLayout(compositeLayout);	composite.setLayoutData(new GridData(GridData.VERTICAL_ALIGN_FILL | GridData.HORIZONTAL_ALIGN_FILL));	viewer = new TextViewer(composite,SWT.WRAP | SWT.V_SCROLL | SWT.H_SCROLL);	GridData data = new GridData(GridData.FILL_BOTH);	viewer.setEditable(false);	viewer.getControl().setLayoutData(data);	viewer.setDocument(document);	viewer.getTextWidget().setFont(ANT_FONT);	viewer.getTextWidget().setStyleRanges((StyleRange[]) styleRangeVector.toArray(new StyleRange[styleRangeVector.size()]));	addContributions();	initializeToolbar();}protected void initializeToolbar() {	IToolBarManager tbm= getViewSite().getActionBars().getToolBarManager();	tbm.add(clearOutputAction);	getViewSite().getActionBars().updateActionBars();}public void dispose() {	if (instances.size() == 1) {		// all the consoles are diposed: we can dispose the colors as well and remove the property listener		ERROR_COLOR.dispose();		WARN_COLOR.dispose();		INFO_COLOR.dispose();		VERBOSE_COLOR.dispose();		DEBUG_COLOR.dispose();		ANT_FONT.dispose();				AntUIPlugin.getPlugin().getPreferenceStore().removePropertyChangeListener(changeListener);	}		instances.remove(this);	super.dispose();}}